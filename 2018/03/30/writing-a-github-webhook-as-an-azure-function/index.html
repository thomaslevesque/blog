<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Writing a GitHub Webhook as an Azure Function - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://thomaslevesque.com/2018/03/30/writing-a-github-webhook-as-an-azure-function/">
  <meta property="og:site_name" content="Thomas Levesque&#39;s .NET Blog">
  <meta property="og:title" content="Writing a GitHub Webhook as an Azure Function">
  <meta property="og:description" content="I recently experimented with Azure Functions and GitHub apps, and I wanted to share what I learned.
A bit of background As you may already know, I’m one of the maintainers of the FakeItEasy mocking library. As is common in open-source projects, we use a workflow based on feature branches and pull requests. When a change is requested in a PR during code review, we usually make the change as a fixup commit, because it makes it easier to review, and because we like to keep a clean history.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2018-03-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2018-03-30T00:00:00+00:00">
    <meta property="article:tag" content="Azure">
    <meta property="article:tag" content="Azure Functions">
    <meta property="article:tag" content="C#">
    <meta property="article:tag" content="GitHub">
    <meta property="article:tag" content="Ngrok">
    <meta property="article:tag" content="Webhook">

		<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Writing a GitHub Webhook as an Azure Function">
<meta name="twitter:description" content="I recently experimented with Azure Functions and GitHub apps, and I wanted to share what I learned.
A bit of background As you may already know, I&rsquo;m one of the maintainers of the FakeItEasy mocking library. As is common in open-source projects, we use a workflow based on feature branches and pull requests. When a change is requested in a PR during code review, we usually make the change as a fixup commit, because it makes it easier to review, and because we like to keep a clean history.">

	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">

	<link rel="shortcut icon" href="/favicon.ico">
		
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-18RG5M4ZD6"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-18RG5M4ZD6');
        }
      </script>
    
  


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
					<div class="logo__tagline">Tips, tricks and thoughts about .NET development</div>
				</div>
		</a>
	</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<a class="main__header__type" href="/posts/">posts</a>
			<h1 class="post__title">Writing a GitHub Webhook as an Azure Function</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0a14 14 0 1 1 0 28 1 1 0 0 1 0-28m0 3a3 3 0 1 0 0 22 3 3 0 0 0 0-22m1 4h-2v8.4l6.8 4.4L22 18l-6-3.8z"/></svg><time class="meta__text" datetime="2018-03-30T00:00:00Z">March 30, 2018</time></div></div>
		</header><div class="content post__content clearfix">
			<p>I recently experimented with Azure Functions and GitHub apps, and I wanted to share what I learned.</p>
<h2 id="a-bit-of-background">A bit of background</h2>
<p>As you may already know, I&rsquo;m one of the maintainers of the <a href="https://fakeiteasy.github.io/">FakeItEasy</a> mocking library. As is common in open-source projects, we use a workflow based on feature branches and pull requests. When a change is requested in a PR during code review, we usually make the change as a <a href="http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html">fixup commit</a>, because it makes it easier to review, and because we like to keep a clean history. When the changes are approved, the author squashes the fixup commits before the PR is merged. Unfortunately, I&rsquo;m a little absent minded, and when I review a PR, I often forget to wait for the author to squash their commits before I merge&hellip; This causes the fixup commits to appear in the main dev branch, which is ugly.</p>
<p>Which leads me to the point of this post: I wanted to make a bot that could prevent a PR from being merged if it had commits that needed to be squashed (i.e. commits whose messages start with <code>fixup!</code> or <code>squash!</code>). And while I was at it, I thought I might as well make it usable by everyone, so I made it a <a href="https://developer.github.com/apps/">GitHub app</a>: <a href="https://github.com/apps/dontmergemeyet">DontMergeMeYet</a>.</p>
<h2 id="github-apps">GitHub apps</h2>
<p>Now, you might be wondering, what on Earth is a GitHub app? It&rsquo;s simply a third-party application that is granted access to a GitHub repository using its own identity; what it can do with the repo depends on which permissions were granted. A GitHub app can also receive <a href="https://developer.github.com/webhooks/">webhook</a> notifications when events occur in the repo (e.g. a comment is posted, a pull request is opened, etc.).</p>
<p>A GitHub app could, for instance, react when a pull request is opened or updated, examine the PR details, and add a <a href="https://developer.github.com/v3/repos/statuses/">commit status</a> to indicate whether the PR is ready to merge or not (this <a href="https://github.com/apps/wip">WIP app</a> does this, but doesn&rsquo;t take fixup commits into account).</p>
<p>As you can see, it&rsquo;s a pretty good fit for what I&rsquo;m trying to do!</p>
<p>In order to create a GitHub app, you need to go to the <a href="https://github.com/settings/apps">GitHub apps page</a>, and click <em>New GitHub app</em>. You then fill in at least the name, homepage, and webhook URL, give the app the necessary permissions, and subscribe to the webhook events you need. In my case, I only needed read-only access to pull requests, read-write access to commit statuses, and to receive pull request events.</p>
<p>At this point, we don&rsquo;t yet have an URL for the webhook, so enter any valid URL; we&rsquo;ll change it later after we actually implemented the app.</p>
<h2 id="azure-functions">Azure Functions</h2>
<p>I hadn&rsquo;t paid much attention to <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview">Azure Functions</a> before, because I didn&rsquo;t really see the point. So I started to implement my webhook as a full-blown ASP.NET Core app, but then I realized several things:</p>
<ul>
<li>My app only had a single HTTP endpoint</li>
<li>It was fully stateless and didn&rsquo;t need a database</li>
<li>If I wanted the webhook to always respond quickly, the Azure App Service had to be &ldquo;always on&rdquo;; that option isn&rsquo;t available in free plans, and I didn&rsquo;t want to pay a fortune for a better service plan.</li>
</ul>
<p>I looked around and realized that Azure Functions had a &ldquo;consumption plan&rdquo;, with a generous amount (1 million per month) of free requests before I had to pay anything, and functions using this plan are &ldquo;always on&rdquo;. Since I had a single endpoint and no persistent state, an Azure Function seemed to be the best fit for my requirements.</p>
<p>Interestingly, Azure Functions can be triggered, among other things, by GitHub webhooks. This is very convenient as it takes care of <a href="https://developer.github.com/webhooks/securing/">validating the payload signature</a>.</p>
<p>So, Azure Functions turn out to be a perfect match for implementing my webhook. Let&rsquo;s look at how to create one.</p>
<h2 id="creating-an-azure-function-triggered-by-a-github-webhook">Creating an Azure Function triggered by a GitHub webhook</h2>
<p>It&rsquo;s possible to write Azure functions in JavaScript, C# (csx) or F# directly in the portal, but I wanted the comfort of the IDE, so I used Visual Studio. To write an Azure Function in VS, follow the instructions on <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-your-first-function-visual-studio">this page</a>. When you create the project, a dialog appears to let you choose some options:</p>
<p><img src="new-function-dialog.png" alt="New function dialog"></p>
<ul>
<li>version of the Azure Functions runtime: v1 targets the full .NET Framework, v2 targets .NET Core. I picked v1, because I had trouble with the dependencies in .NET Core.</li>
<li>Trigger: GitHub webhooks don&rsquo;t appear here, so just pick &ldquo;HTTP Trigger&rdquo;, we&rsquo;ll make the necessary changes in the code.</li>
<li>Storage account: pick the storage emulator; when you publish the function, a real Azure storage account will be set instead</li>
<li>Access rights: it doesn&rsquo;t matter what you pick, we&rsquo;ll override it in the code.</li>
</ul>
<p>The project template creates a class named <code>Function1</code> with a <code>Run</code> method that looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Function1</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [FunctionName(&#34;Function1&#34;)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task&lt;HttpResponseMessage&gt; Run(
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">        [HttpTrigger(AuthorizationLevel.Anonymous, &#34;get&#34;, &#34;post&#34;, Route = null)]</span>HttpRequestMessage req, TraceWriter log)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Rename the class to something that makes more sense, e.g. <code>GitHubWebHook</code>, and don&rsquo;t forget to change the name in the <code>FunctionName</code> attribute as well.</p>
<p>Now we need to tell the Azure Functions runtime that this function is triggered by a GitHub webhook. To do this, change the method signature to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">    [FunctionName(&#34;GitHubWebHook&#34;)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task&lt;HttpResponseMessage&gt; Run(
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">        [HttpTrigger(&#34;POST&#34;, WebHookType = &#34;github&#34;)]</span> HttpRequestMessage req,
</span></span><span style="display:flex;"><span>        TraceWriter log)
</span></span></code></pre></div><p>GitHub webhooks always use the HTTP <code>POST</code> method; the <code>WebHookType</code> property is set to <code>&quot;github&quot;</code> to indicate that it&rsquo;s a GitHub webhook.</p>
<p>Note that it doesn&rsquo;t really matter what we respond to the webhook request; GitHub doesn&rsquo;t do anything with the response. I chose to return a 204 (No content) response, but you can return a 200 or anything else, it doesn&rsquo;t matter.</p>
<h2 id="publishing-the-azure-function">Publishing the Azure Function</h2>
<p>To publish your function, just right click on the Function App project, and click <em>Publish</em>. This will show a wizard that will let you create a new Function App resource on your Azure subscription, or select an existing one. Not much to explain here, it&rsquo;s pretty straightforward; just follow the wizard!</p>
<p>When the function is published, you need to tell GitHub how to invoke it. Open the <a href="https://portal.azure.com/">Azure portal</a> in your browser, navigate to your new Function App, and select the <code>GitHubWebHook</code> function. This will show the content of the (generated) <code>function.json</code> file. Above the code view, you will see two links: <em>Get function URL</em>, and <em>Get GitHub secret</em>:</p>
<p><img src="azure-function-url-and-secret.png" alt="Azure Function URL and secret"></p>
<p>You need to copy the URL to the <em>Webhook URL</em> field in the GitHub app settings, and copy the secret to the <em>Webhook secret</em> field. This secret is used to calculate a signature for webhook payloads, so that the Azure Function can ensure the payloads really come from GitHub. As I mentioned earlier, this verification is done automatically when you use a GitHub HTTP trigger.</p>
<p>And that&rsquo;s it, your webhook is online! Now you can go install the GitHub app into one of your repositories, and your webhook will start receiving events for this repo.</p>
<h2 id="points-of-interest">Points of interest</h2>
<p>I won&rsquo;t describe the whole implementation of my webhook in this post, because it would be too long and most of it isn&rsquo;t that interesting, but I will just highlight a few points of interest. You can find the complete code <a href="https://github.com/thomaslevesque/DontMergeMeYet">on GitHub</a>.</p>
<h3 id="parsing-the-payload">Parsing the payload</h3>
<p>Rather than reinventing the wheel, we can leverage the <a href="https://github.com/octokit/octokit.net">Octokit .NET library</a>. Octokit is a library made by GitHub to consume the GitHub REST API. It contains classes representing the entities used in the API, including webhook payloads, so we can just deserialize the request content as a <code>PullRequestEventPayload</code>. However, if we just try to do this with JSON.NET, this isn&rsquo;t going to work: Octokit doesn&rsquo;t use JSON.NET, so the classes aren&rsquo;t decorated with JSON.NET attributes to map the C# property names to the JSON property names. Instead, we need to use the JSON serializer that is included in Octokit, called <code>SimpleJsonSerializer</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task&lt;PullRequestEventPayload&gt; DeserializePayloadAsync(HttpContent content)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> json = <span style="color:#66d9ef">await</span> content.ReadAsStringAsync();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> serializer = <span style="color:#66d9ef">new</span> SimpleJsonSerializer();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> serializer.Deserialize&lt;PullRequestEventPayload&gt;(json);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There&rsquo;s also another issue: the <code>PullRequestEventPayload</code> from Octokit is missing the <code>Installation</code> property, which we&rsquo;re going to need later to authenticate with the GitHub API. An easy workaround is to make a new class that inherits <code>PullRequestEventPayload</code> and add the new property:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PullRequestPayload</span> : PullRequestEventPayload
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Installation Installation { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Installation</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Id { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we&rsquo;ll just use <code>PullRequestPayload</code> instead of <code>PullRequestEventPayload</code>.</p>
<h3 id="authenticating-with-the-github-api">Authenticating with the GitHub API</h3>
<p>We&rsquo;re going to need to call the GitHub REST API for two things:</p>
<ul>
<li>to get the list of commits in the pull request</li>
<li>to update the commit status</li>
</ul>
<p>In order to access the API, we&rsquo;re going to need credentials&hellip; but which credentials? We could just generate a <a href="https://github.com/settings/tokens">personal access token</a> and use that, but then we would access the API as a &ldquo;real&rdquo; GitHub user, and we would only be able to access our own repositories (for writing, at least).</p>
<p>As I mentioned earlier, GitHub apps have their own identity. What I didn&rsquo;t say is that when authenticated as themselves, there isn&rsquo;t much they&rsquo;re allowed to do: they can only get management information about themselves, and get a token to authenticate as an <em>installation</em>. An installation is, roughly, an instance of the application that is installed on one or more repo. When someone installs your app on their repo, it creates an installation. Once you get a token for an installation, you can access all the APIs allowed by the app&rsquo;s permissions on the repos it&rsquo;s installed on.</p>
<p>However, there are a few hoops to jump through to get this token&hellip; <a href="https://developer.github.com/apps/building-github-apps/authentication-options-for-github-apps/">This page</a> describes the process in detail.</p>
<p>The first step is to generate a JSON Web Token (JWT) for the app. This token has to contain the following claims:</p>
<ul>
<li><code>iat</code>: the timestamp at which the token was issued</li>
<li><code>exp</code>: the timestamp at which the token expires</li>
<li><code>iss</code>: the issuer, which is actually the app ID (found in the GitHub app settings page)</li>
</ul>
<p>This JWT needs to be signed with the RS256 algorithm (RSA signature with SHA256); in order to sign it, you need a private key, which must be generated from the GitHub app settings page. You can download the private key in PEM format, and store it somewhere your app can access it. Unfortunately, the .NET APIs to generate and sign a JWT don&rsquo;t handle the PEM format, they need an <code>RSAParameters</code> object&hellip; But Stackoverflow is our friend, and <a href="https://stackoverflow.com/a/26978561/98713">this answer</a> contains the code we need to convert a PEM private key to an <code>RSAParameters</code> object. I just kept <a href="https://github.com/thomaslevesque/DontMergeMeYet/blob/master/src/DontMergeMeYet/Services/CryptoHelper.cs">the part I needed</a>, and manually reformatted the PEM private key to remove the header, footer, and newlines, so that it could easily be stored in the settings as a single line of text.</p>
<p>Once you have the private key as an <code>RSAParameters</code> object, you can generate a JWT like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> GetTokenForApplication()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> key = <span style="color:#66d9ef">new</span> RsaSecurityKey(_settings.RsaParameters);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> creds = <span style="color:#66d9ef">new</span> SigningCredentials(key, SecurityAlgorithms.RsaSha256);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> now = DateTime.UtcNow;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> token = <span style="color:#66d9ef">new</span> JwtSecurityToken(claims: <span style="color:#66d9ef">new</span>[]
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Claim(<span style="color:#e6db74">&#34;iat&#34;</span>, now.ToUnixTimeStamp().ToString(), ClaimValueTypes.Integer),
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Claim(<span style="color:#e6db74">&#34;exp&#34;</span>, now.AddMinutes(<span style="color:#ae81ff">10</span>).ToUnixTimeStamp().ToString(), ClaimValueTypes.Integer),
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Claim(<span style="color:#e6db74">&#34;iss&#34;</span>, _settings.AppId)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        signingCredentials: creds);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> jwt = <span style="color:#66d9ef">new</span> JwtSecurityTokenHandler().WriteToken(token);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> jwt;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A few notes about this code:</p>
<ul>
<li>It requires the following NuGet packages:
<ul>
<li>Microsoft.IdentityModel.Tokens 5.2.1</li>
<li>System.IdentityModel.Tokens.Jwt 5.2.1</li>
</ul>
</li>
<li><code>ToUnixTimeStamp</code> is an extension method that converts a <code>DateTime</code> to a UNIX timestamp; you can find it <a href="https://github.com/thomaslevesque/DontMergeMeYet/blob/master/src/DontMergeMeYet/Extensions/DateTimeExtensions.cs#L9">here</a></li>
<li>As per the GitHub documentation, the token lifetime cannot exceed 10 minutes</li>
</ul>
<p>Once you have the JWT, you can get an installation access token by calling the <a href="https://developer.github.com/v3/apps/#create-a-new-installation-token">&ldquo;new installation token&rdquo; API endpoint</a>. You can authenticate to this endpoint by using the generated JWT as a <code>Bearer</code> token</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;<span style="color:#66d9ef">string</span>&gt; GetTokenForInstallationAsync(<span style="color:#66d9ef">int</span> installationId)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> appToken = GetTokenForApplication();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> HttpClient())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">string</span> url = <span style="color:#e6db74">$&#34;https://api.github.com/installations/{installationId}/access_tokens&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> request = <span style="color:#66d9ef">new</span> HttpRequestMessage(HttpMethod.Post, url)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Headers =
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Authorization = <span style="color:#66d9ef">new</span> AuthenticationHeaderValue(<span style="color:#e6db74">&#34;Bearer&#34;</span>, appToken),
</span></span><span style="display:flex;"><span>                UserAgent =
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    ProductInfoHeaderValue.Parse(<span style="color:#e6db74">&#34;DontMergeMeYet&#34;</span>),
</span></span><span style="display:flex;"><span>                },
</span></span><span style="display:flex;"><span>                Accept =
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    MediaTypeWithQualityHeaderValue.Parse(<span style="color:#e6db74">&#34;application/vnd.github.machine-man-preview+json&#34;</span>)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">await</span> client.SendAsync(request))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            response.EnsureSuccessStatusCode();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> json = <span style="color:#66d9ef">await</span> response.Content.ReadAsStringAsync();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> obj = JObject.Parse(json);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> obj[<span style="color:#e6db74">&#34;token&#34;</span>]?.Value&lt;<span style="color:#66d9ef">string</span>&gt;();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>OK, almost there. Now we just need to use the installation token to call the GitHub API. This can be done easily with Octokit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> IGitHubClient CreateGitHubClient(<span style="color:#66d9ef">string</span> installationToken)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> userAgent = <span style="color:#66d9ef">new</span> ProductHeaderValue(<span style="color:#e6db74">&#34;DontMergeMeYet&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> GitHubClient(userAgent)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Credentials = <span style="color:#66d9ef">new</span> Credentials(installationToken)
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And that&rsquo;s it, you can now call the GitHub API as an installation of your app.</p>
<p>Note: the code above isn&rsquo;t exactly what you&rsquo;ll find in <a href="https://github.com/thomaslevesque/DontMergeMeYet">the repo</a>; I simplified it a little for the sake of clarity.</p>
<h3 id="testing-locally-using-ngrok">Testing locally using ngrok</h3>
<p>When creating your Azure Function, it&rsquo;s useful to be able to debug on your local machine. However, how will GitHub be able to call your function if it doesn&rsquo;t have a publicly accessible URL? The answer is a tool called <a href="https://ngrok.com/">ngrok</a>. Ngrok can create a temporary host name that forwards all traffic to a port on your local machine. To use it, create an account (it&rsquo;s free) and download the command line tool. Once logged in to the ngrok website, a <a href="https://dashboard.ngrok.com/get-started">page</a> will give you the command to save an authentication token on your machine. Just execute this command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ngrok authtoken 1beErG2VTJJ0azL3r2SBn_2iz8johqNv612vaXa3Rkm
</span></span></code></pre></div><p>Start your Azure Function in debug from Visual Studio; the console will show you the local URL of the function, something like <code>http://localhost:7071/api/GitHubWebHook</code>. Note the port, and in a new console, start ngrok like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ngrok http <span style="color:#ae81ff">7071</span> --host-header rewrite
</span></span></code></pre></div><p>This will create a new hostname and start forwarding traffic to the 7071 port on your machine. The <code>--host-header rewrite</code> argument causes ngrok to change the <code>Host</code> HTTP header to localhost, rather than the temporary hostname; Azure Functions don&rsquo;t work correctly without this.</p>
<p>You can see the temporary hostname in the command output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>ngrok by @inconshreveable                                                                                                                                                                                         (Ctrl+C to quit)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Session Status                online
</span></span><span style="display:flex;"><span>Account                       Thomas Levesque (Plan: Free)
</span></span><span style="display:flex;"><span>Version                       2.2.8
</span></span><span style="display:flex;"><span>Region                        United States (us)
</span></span><span style="display:flex;"><span>Web Interface                 http://127.0.0.1:4040
</span></span><span style="display:flex;"><span>Forwarding                    http://89e14c16.ngrok.io -&gt; localhost:7071
</span></span><span style="display:flex;"><span>Forwarding                    https://89e14c16.ngrok.io -&gt; localhost:7071
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Connections                   ttl     opn     rt1     rt5     p50     p90
</span></span><span style="display:flex;"><span>                              0       0       0.00    0.00    0.00    0.00
</span></span></code></pre></div><p>Finally, go to the GitHub app settings, and change the webook URL to <code>https://89e14c16.ngrok.io/api/GitHubWebHook</code> (i.e. the temporary domain with the same path as the local URL).</p>
<p>Now you&rsquo;re all set. GitHub will send the webhook payloads to ngrok, which will forward them to your app running locally.</p>
<p>Note that unless you have a paid plan for ngrok, the temporary subdomain changes every time you start the tool, which is annoying. So it&rsquo;s better to keep it running for the whole development session, otherwise you will need to change the GitHub app settings again.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Hopefully you learned a few things from this article. With Azure Functions, it&rsquo;s almost trivial to implement a GitHub webhook (the only tricky part is the authentication to call the GitHub API, but not all webhooks need it). It&rsquo;s much lighter than a full-blown web app, and much simpler to write: you don&rsquo;t have to care about MVC, routing, services, etc. And if it wasn&rsquo;t enough, the pricing model for Azure Functions make it a very cheap option for hosting a webhook!</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M4 0h8s2 0 4 2l15 15s2 2 0 4L21 31s-2 2-4 0L2 16s-2-2-2-4V3s0-3 4-3m3 10a3 3 0 0 0 0-6 3 3 0 0 0 0 6"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/azure/" rel="tag">Azure</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/azure-functions/" rel="tag">Azure Functions</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/c%23/" rel="tag">C#</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/github/" rel="tag">GitHub</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/ngrok/" rel="tag">ngrok</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/webhook/" rel="tag">Webhook</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Thomas Levesque avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Thomas Levesque</span>
	</div>
	<div class="authorbox__description">
		Thomas Levesque is a French software developer, currently living in Québec, Canada.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Understanding the ASP.NET Core middleware pipeline</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hosting an ASP.NET Core 2 application on a Raspberry Pi</p>
		</a>
	</div>
</nav>
<div class="giscus">
    <script src="https://giscus.app/client.js"
        data-repo="thomaslevesque/blog"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyNTkxNDk0Njk="
        data-category="Blog comments"
        data-category-id="DIC_kwDOD3JOnc4CPJVg"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
    </script>
</div>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<input class="widget-search__field" type="search" placeholder="Search…" value="" name="q" aria-label="Search…">
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://thomaslevesque.com/">
	</form>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Social</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/thomaslevesque" target="_blank">
				<svg class="widget-social__link-icon icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
				<span>Twitter</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/thomaslevesque" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>

		
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Mastodon"  rel="me" href="https://mastodon.cloud/@thomaslevesque" target="_blank">
					<svg class="widget-social__link-icon icon icon-mastodon" width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" xml:space="preserve">
    <path d="M21.327 8.566c0-4.339-2.843-5.61-2.843-5.61-1.433-.658-3.894-.935-6.451-.956h-.063c-2.557.021-5.016.298-6.45.956 0 0-2.843 1.272-2.843 5.61 0 .993-.019 2.181.012 3.441.103 4.243.778 8.425 4.701 9.463 1.809.479 3.362.579 4.612.51 2.268-.126 3.541-.809 3.541-.809l-.075-1.646s-1.621.511-3.441.449c-1.804-.062-3.707-.194-3.999-2.409a4.523 4.523 0 0 1-.04-.621s1.77.433 4.014.536c1.372.063 2.658-.08 3.965-.236 2.506-.299 4.688-1.843 4.962-3.254.434-2.223.398-5.424.398-5.424zm-3.353 5.59h-2.081V9.057c0-1.075-.452-1.62-1.357-1.62-1 0-1.501.647-1.501 1.927v2.791h-2.069V9.364c0-1.28-.501-1.927-1.502-1.927-.905 0-1.357.546-1.357 1.62v5.099H6.026V8.903c0-1.074.273-1.927.823-2.558.566-.631 1.307-.955 2.228-.955 1.065 0 1.872.409 2.405 1.228l.518.869.519-.869c.533-.819 1.34-1.228 2.405-1.228.92 0 1.662.324 2.228.955.549.631.822 1.484.822 2.558v5.253z" />
</svg>
				<span>Mastodon</span>
			</a>
		</div>
		
	</div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/2024/04/25/running-a-github-actions-workflow-that-doesnt-exist-yet-on-the-default-branch/">Running a GitHub Actions workflow that doesn&#39;t exist yet on the default branch</a></li>
			<li class="widget__item"><a class="widget__link" href="/2022/11/01/building-a-url-shortener-in-12-lines-of-code-using-cloudflare-workers/">Building a URL shortener in 12 lines of code using Cloudflare Workers</a></li>
			<li class="widget__item"><a class="widget__link" href="/2022/09/19/using-multiple-json-serialization-settings-in-aspnet-core/">Using multiple JSON serialization settings in ASP.NET Core</a></li>
			<li class="widget__item"><a class="widget__link" href="/2021/11/12/building-a-project-that-target-net-45-in-visual-studio-2022/">Building a project that target .NET Framework 4.5 in Visual Studio 2022</a></li>
			<li class="widget__item"><a class="widget__link" href="/2021/11/04/a-quick-review-of-csharp-10-new-language-features/">A quick review of C# 10 new language features</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Top tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23/" title="c#">c#</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wpf/" title="wpf">wpf</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/asp.net-core/" title="asp.net core">asp.net core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xaml/" title="xaml">xaml</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/async/" title="async">async</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/visual-studio/" title="visual studio">visual studio</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/json/" title="json">json</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-core/" title=".net core">.net core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23-9/" title="c# 9">c# 9</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linq/" title="linq">linq</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/unit-testing/" title="unit testing">unit testing</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/binding/" title="binding">binding</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dependency-injection/" title="dependency injection">dependency injection</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/markup-extension/" title="markup extension">markup extension</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mvvm/" title="mvvm">mvvm</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 Thomas Levesque.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>