<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Markup Extension on Thomas Levesque&#39;s .NET Blog</title>
    <link>https://thomaslevesque.com/tags/markup-extension/</link>
    <description>Recent content in Markup Extension on Thomas Levesque&#39;s .NET Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Sep 2011 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://thomaslevesque.com/tags/markup-extension/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[WPF 4.5] Subscribing to an event using a markup extension</title>
      <link>https://thomaslevesque.com/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/</link>
      <pubDate>Fri, 23 Sep 2011 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2011/09/23/wpf-4-5-subscribing-to-an-event-using-a-markup-extension/</guid>
      <description>It&amp;rsquo;s been a while since I last wrote about markup extensions&amp;hellip; The release of Visual Studio 11 Developer Preview, which introduces a number of new features to WPF, just gave me a reason to play with them again. The feature I&amp;rsquo;m going to discuss here is perhaps not the most impressive, but it fills in a gap of the previous versions: the support of markup extensions for events.&#xA;Until now, it was possible to use a markup extension in XAML to assign a value to a property, but we couldn&amp;rsquo;t do the same to subscribe to an event.</description>
    </item>
    <item>
      <title>[WPF] Markup extensions and templates</title>
      <link>https://thomaslevesque.com/2009/08/23/wpf-markup-extensions-and-templates/</link>
      <pubDate>Sun, 23 Aug 2009 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2009/08/23/wpf-markup-extensions-and-templates/</guid>
      <description>Note : This post follows the one about a a markup extension that can update its target, and reuses the same code.&#xA;You may have noticed that using a custom markup extension in a template sometimes lead to unexpected results&amp;hellip; In this post I&amp;rsquo;ll explain what the problem is, and how to create a markup extensions that behaves correctly in a template.&#xA;The problem Let&amp;rsquo;s take the example from the previous post : a markup extension which gives the state of network connectivity, and updates its target when the network is connected or disconnected :</description>
    </item>
    <item>
      <title>[WPF] A markup extension that can update its target</title>
      <link>https://thomaslevesque.com/2009/07/28/wpf-a-markup-extension-that-can-update-its-target/</link>
      <pubDate>Tue, 28 Jul 2009 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2009/07/28/wpf-a-markup-extension-that-can-update-its-target/</guid>
      <description>If you have read my previous posts on the topic, you know I&amp;rsquo;m a big fan of custom markup extensions&amp;hellip; However, they have a limitation that can be quite annoying : they are only evaluated once. Yet it would be useful to be able to evaluate them again to update the target property, like a binding&amp;hellip; It could be useful in various cases, for instance :&#xA;if the value of the markup extension can change in response to an event</description>
    </item>
    <item>
      <title>[WPF] Using InputBindings with the MVVM pattern</title>
      <link>https://thomaslevesque.com/2009/03/17/wpf-using-inputbindings-with-the-mvvm-pattern/</link>
      <pubDate>Tue, 17 Mar 2009 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2009/03/17/wpf-using-inputbindings-with-the-mvvm-pattern/</guid>
      <description>If you develop WPF applications according to the Model-View-ViewModel pattern, you may have faced this issue : in XAML, how to bind a key or mouse gesture to a ViewModel command ? The obvious and intuitive approach would be this one :&#xA;&amp;lt;UserControl.InputBindings&amp;gt; &amp;lt;KeyBinding Modifiers=&amp;#34;Control&amp;#34; Key=&amp;#34;E&amp;#34; Command=&amp;#34;{Binding EditCommand}&amp;#34;/&amp;gt; &amp;lt;/UserControl.InputBindings&amp;gt; Unfortunately, this code doesn&amp;rsquo;t work, for two reasons :&#xA;The Command property is not a dependency property, so you cannot assign it through binding InputBindings are not part of the logical or visual tree of the control, so they don&amp;rsquo;t inherit the DataContext A solution would be to create the InputBindings in the code-behind, but in the MVVM pattern we usually prefer to avoid this&amp;hellip; I spent a long time looking for alternative solutions to do this in XAML, but most of them are quite complex and unintuitive.</description>
    </item>
    <item>
      <title>[WPF] Binding to application settings using a markup extension</title>
      <link>https://thomaslevesque.com/2008/11/18/wpf-binding-to-application-settings-using-a-markup-extension/</link>
      <pubDate>Tue, 18 Nov 2008 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2008/11/18/wpf-binding-to-application-settings-using-a-markup-extension/</guid>
      <description>Hi, this is my first post on this blog, I hope you will enjoy it ;-). If you want to know a few things about me, please check out this page.&#xA;The end-user of any application expects that his preferences (window size, state of this or that option&amp;hellip;) are saved to be restored at the next run : that&amp;rsquo;s why .NET 2.0 introduced application settings as a unified way to persist these settings.</description>
    </item>
  </channel>
</rss>
