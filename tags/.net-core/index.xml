<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.net core on Thomas Levesque .NET Blog</title>
    <link>https://blog2.thomaslevesque.net/tags/.net-core/</link>
    <description>Recent content in .net core on Thomas Levesque .NET Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2020 13:14:03 +0000</lastBuildDate>
    
	<atom:link href="https://blog2.thomaslevesque.net/tags/.net-core/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lazily resolving services to fix circular dependencies in .NET Core</title>
      <link>https://blog2.thomaslevesque.net/2020/03/18/lazily-resolving-services-to-fix-circular-dependencies-in-net-core/</link>
      <pubDate>Wed, 18 Mar 2020 13:14:03 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2020/03/18/lazily-resolving-services-to-fix-circular-dependencies-in-net-core/</guid>
      <description>The problem with circular dependencies When building an application, good design dictates that you should avoid circular dependencies between your services. A circular dependency is when some components depend on each other, directly or indirectly, e.g. A depends on B which depends on C which depends on A:
It is generally agreed that this should be avoided; I won&amp;rsquo;t go into the details of the conceptual and theoretical reasons, because there are plenty of resources about it on the web.</description>
    </item>
    
    <item>
      <title>Making a WPF app using a SDK-style project with MSBuildSdkExtras</title>
      <link>https://blog2.thomaslevesque.net/2018/11/23/making-a-wpf-app-using-a-sdk-style-project-with-msbuildsdkextras/</link>
      <pubDate>Fri, 23 Nov 2018 13:17:51 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/11/23/making-a-wpf-app-using-a-sdk-style-project-with-msbuildsdkextras/</guid>
      <description>Ever since the first stable release of the .NET Core SDK, we&amp;rsquo;ve enjoyed a better C# project format, often called &amp;ldquo;SDK-style&amp;rdquo; because you specify a SDK to use in the project file. It&amp;rsquo;s still a .csproj XML file, it&amp;rsquo;s still based on MSBuild, but it&amp;rsquo;s much more lightweight and much easier to edit by hand. Personally, I love it and use it everywhere I can.
However, out of the box, it&amp;rsquo;s only usable for some project types: ASP.</description>
    </item>
    
    <item>
      <title>Hosting an ASP.NET Core 2 application on a Raspberry Pi</title>
      <link>https://blog2.thomaslevesque.net/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/</link>
      <pubDate>Tue, 17 Apr 2018 20:57:40 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/</guid>
      <description>As you probably know, .NET Core runs on many platforms: Windows, macOS, and many UNIX/Linux variants, whether on x86/x64 architectures or on ARM. This enables a wide range of interesting scenarios&amp;hellip; For instance, is a very small machine like a Raspberry Pi, which its low performance ARM processor and small amount of RAM (1 GB on my RPi 2 Model B), enough to host an ASP.NET Core web app? Yes it is!</description>
    </item>
    
    <item>
      <title>Understanding the ASP.NET Core middleware pipeline</title>
      <link>https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/</link>
      <pubDate>Tue, 27 Mar 2018 06:00:38 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/</guid>
      <description>Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP.</description>
    </item>
    
    <item>
      <title>Common MSBuild properties and items with Directory.Build.props</title>
      <link>https://blog2.thomaslevesque.net/2017/09/18/common-msbuild-properties-and-items-with-directory-build-props/</link>
      <pubDate>Mon, 18 Sep 2017 17:59:10 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2017/09/18/common-msbuild-properties-and-items-with-directory-build-props/</guid>
      <description>To be honest, I never really liked MSBuild until recently. The project files generated by Visual Studio were a mess, most of their content was redundant, you had to unload the projects to edit them, it was poorly documented&amp;hellip; But with the advent of .NET Core and the new &amp;ldquo;SDK-style&amp;rdquo; projects, it&amp;rsquo;s become much, much better.
MSBuild 15 introduced a pretty cool feature: implicit imports (I don&amp;rsquo;t know if it&amp;rsquo;s the official name, but I&amp;rsquo;ll use it anyway).</description>
    </item>
    
    <item>
      <title>Linq performance improvements in .NET Core</title>
      <link>https://blog2.thomaslevesque.net/2017/03/29/linq-performance-improvements-in-net-core/</link>
      <pubDate>Tue, 28 Mar 2017 22:18:21 +0000</pubDate>
      
      <guid>https://blog2.thomaslevesque.net/2017/03/29/linq-performance-improvements-in-net-core/</guid>
      <description>By now, you&amp;rsquo;re probably aware that Microsoft released an open-source and cross-platform version of the .NET platform: .NET Core. This means you can now build and run .NET apps on Linux or macOS. This is pretty cool in itself, but it doesn&amp;rsquo;t end there: .NET Core also brings a lot of improvements to the Base Class Library.
For instance, Linq has been made faster in .NET Core. I made a little benchmark to compare the performance of some common Linq methods, and the results are quite impressive:</description>
    </item>
    
  </channel>
</rss>