<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.net core on Thomas Levesque&#39;s .NET Blog</title>
    <link>https://thomaslevesque.com/tags/.net-core/</link>
    <description>Recent content in .net core on Thomas Levesque&#39;s .NET Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Sep 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://thomaslevesque.com/tags/.net-core/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Automatic factory with Microsoft.Extensions.DependencyInjection and Castle DynamicProxy</title>
      <link>https://thomaslevesque.com/2020/09/27/automatic-factory-with-microsoft-extensions-dependencyinjection-and-castle-dynamicproxy/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2020/09/27/automatic-factory-with-microsoft-extensions-dependencyinjection-and-castle-dynamicproxy/</guid>
      <description>Dependency injection: the good and the bad Dependency injection (DI) is a great pattern, which can really help make your code cleaner, more decoupled and more testable. There are many DI libraries, like Autofac, Lamar (StructureMap&amp;rsquo;s successor), Castle Windsor, etc., but lately I&amp;rsquo;ve mostly been using the one provided by Microsoft in .NET Core : Microsoft.Extensions.DependencyInjection. It&amp;rsquo;s not the most full-featured (in fact, it&amp;rsquo;s pretty bare-bones), but I find it sufficient in most cases.</description>
    </item>
    <item>
      <title>Lazily resolving services to fix circular dependencies in .NET Core</title>
      <link>https://thomaslevesque.com/2020/03/18/lazily-resolving-services-to-fix-circular-dependencies-in-net-core/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2020/03/18/lazily-resolving-services-to-fix-circular-dependencies-in-net-core/</guid>
      <description>The problem with circular dependencies When building an application, good design dictates that you should avoid circular dependencies between your services. A circular dependency is when some components depend on each other, directly or indirectly, e.g. A depends on B which depends on C which depends on A:
It is generally agreed that this should be avoided; I won&amp;rsquo;t go into the details of the conceptual and theoretical reasons, because there are plenty of resources about it on the web.</description>
    </item>
    <item>
      <title>Making a WPF app using a SDK-style project with MSBuildSdkExtras</title>
      <link>https://thomaslevesque.com/2018/11/23/making-a-wpf-app-using-a-sdk-style-project-with-msbuildsdkextras/</link>
      <pubDate>Fri, 23 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2018/11/23/making-a-wpf-app-using-a-sdk-style-project-with-msbuildsdkextras/</guid>
      <description>Ever since the first stable release of the .NET Core SDK, we&amp;rsquo;ve enjoyed a better C# project format, often called &amp;ldquo;SDK-style&amp;rdquo; because you specify a SDK to use in the project file. It&amp;rsquo;s still a .csproj XML file, it&amp;rsquo;s still based on MSBuild, but it&amp;rsquo;s much more lightweight and much easier to edit by hand. Personally, I love it and use it everywhere I can.
However, out of the box, it&amp;rsquo;s only usable for some project types: ASP.</description>
    </item>
    <item>
      <title>Hosting an ASP.NET Core 2 application on a Raspberry Pi</title>
      <link>https://thomaslevesque.com/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/</link>
      <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2018/04/17/hosting-an-asp-net-core-2-application-on-a-raspberry-pi/</guid>
      <description>As you probably know, .NET Core runs on many platforms: Windows, macOS, and many UNIX/Linux variants, whether on x86/x64 architectures or on ARM. This enables a wide range of interesting scenarios&amp;hellip; For instance, is a very small machine like a Raspberry Pi, which its low performance ARM processor and small amount of RAM (1 GB on my RPi 2 Model B), enough to host an ASP.NET Core web app? Yes it is!</description>
    </item>
    <item>
      <title>Understanding the ASP.NET Core middleware pipeline</title>
      <link>https://thomaslevesque.com/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/</link>
      <pubDate>Tue, 27 Mar 2018 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2018/03/27/understanding-the-asp-net-core-middleware-pipeline/</guid>
      <description>Middlewhat? The ASP.NET Core architecture features a system of middleware, which are pieces of code that handle requests and responses. Middleware are chained to each other to form a pipeline. Incoming requests are passed through the pipeline, where each middleware has a chance to do something with them before passing them to the next middleware. Outgoing responses are also passed through the pipeline, in reverse order. If this sounds very abstract, the following schema from the official ASP.</description>
    </item>
    <item>
      <title>Common MSBuild properties and items with Directory.Build.props</title>
      <link>https://thomaslevesque.com/2017/09/18/common-msbuild-properties-and-items-with-directory-build-props/</link>
      <pubDate>Mon, 18 Sep 2017 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2017/09/18/common-msbuild-properties-and-items-with-directory-build-props/</guid>
      <description>To be honest, I never really liked MSBuild until recently. The project files generated by Visual Studio were a mess, most of their content was redundant, you had to unload the projects to edit them, it was poorly documented&amp;hellip; But with the advent of .NET Core and the new &amp;ldquo;SDK-style&amp;rdquo; projects, it&amp;rsquo;s become much, much better.
MSBuild 15 introduced a pretty cool feature: implicit imports (I don&amp;rsquo;t know if it&amp;rsquo;s the official name, but I&amp;rsquo;ll use it anyway).</description>
    </item>
    <item>
      <title>Linq performance improvements in .NET Core</title>
      <link>https://thomaslevesque.com/2017/03/29/linq-performance-improvements-in-net-core/</link>
      <pubDate>Wed, 29 Mar 2017 00:00:00 +0000</pubDate>
      <guid>https://thomaslevesque.com/2017/03/29/linq-performance-improvements-in-net-core/</guid>
      <description>By now, you&amp;rsquo;re probably aware that Microsoft released an open-source and cross-platform version of the .NET platform: .NET Core. This means you can now build and run .NET apps on Linux or macOS. This is pretty cool in itself, but it doesn&amp;rsquo;t end there: .NET Core also brings a lot of improvements to the Base Class Library.
For instance, Linq has been made faster in .NET Core. I made a little benchmark to compare the performance of some common Linq methods, and the results are quite impressive:</description>
    </item>
  </channel>
</rss>
