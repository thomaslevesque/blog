<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linq on Thomas Levesque&#39;s .NET Blog</title>
    <link>https://thomaslevesque.com/tags/linq/</link>
    <description>Recent content in linq on Thomas Levesque&#39;s .NET Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://thomaslevesque.com/tags/linq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Using foreach with index in C#</title>
      <link>https://thomaslevesque.com/2019/11/18/using-foreach-with-index-in-c/</link>
      <pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2019/11/18/using-foreach-with-index-in-c/</guid>
      <description>Just a quick tip today!
for and foreach loops are among the most useful constructs in a C# developer&amp;rsquo;s toolbox. To iterate a collection, foreach is, in my opinion, more convenient than for in most cases. It works with all collection types, including those that are not indexable such as IEnumerable&amp;lt;T&amp;gt;, and doesn&amp;rsquo;t require to access the current element by its index.
But sometimes, you do need the index of the current item; this usually leads to one of these patterns:</description>
    </item>
    
    <item>
      <title>Linq performance improvements in .NET Core</title>
      <link>https://thomaslevesque.com/2017/03/29/linq-performance-improvements-in-net-core/</link>
      <pubDate>Wed, 29 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2017/03/29/linq-performance-improvements-in-net-core/</guid>
      <description>By now, you&amp;rsquo;re probably aware that Microsoft released an open-source and cross-platform version of the .NET platform: .NET Core. This means you can now build and run .NET apps on Linux or macOS. This is pretty cool in itself, but it doesn&amp;rsquo;t end there: .NET Core also brings a lot of improvements to the Base Class Library.
For instance, Linq has been made faster in .NET Core. I made a little benchmark to compare the performance of some common Linq methods, and the results are quite impressive:</description>
    </item>
    
    <item>
      <title>Optimize ToArray and ToList by providing the number of elements</title>
      <link>https://thomaslevesque.com/2014/12/07/optimize-toarray-and-tolist-by-providing-the-number-of-elements/</link>
      <pubDate>Sun, 07 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2014/12/07/optimize-toarray-and-tolist-by-providing-the-number-of-elements/</guid>
      <description>The ToArray and ToList extension methods are convenient ways to eagerly materialize an enumerable sequence (e.g. a Linq query) into an array or a list. However, there’s something that bothers me: both of these methods are very inefficient if they don’t know the number of elements in the sequence (which is almost always the case when you use them on a Linq query). Let’s focus on ToArray for now (ToList has a few differences, but the principle is mostly the same).</description>
    </item>
    
    <item>
      <title>[WPF] Using Linq to shape data in a CollectionView</title>
      <link>https://thomaslevesque.com/2011/11/30/wpf-using-linq-to-shape-data-in-a-collectionview/</link>
      <pubDate>Wed, 30 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2011/11/30/wpf-using-linq-to-shape-data-in-a-collectionview/</guid>
      <description>WPF provides a simple mechanism for shaping collections of data, via the ICollectionView interface and its Filter, SortDescriptions and GroupDescriptions properties:
// Collection to which the view is bound public ObservableCollection People { get; private set; } ...  // Default view of the People collection ICollectionView view = CollectionViewSource.GetDefaultView(People);  // Show only adults view.Filter = o =&amp;gt; ((Person)o).Age &amp;gt;= 18;  // Sort by last name and first name view.</description>
    </item>
    
    <item>
      <title>[Entity Framework] Using Include with lambda expressions</title>
      <link>https://thomaslevesque.com/2010/10/03/entity-framework-using-include-with-lambda-expressions/</link>
      <pubDate>Sun, 03 Oct 2010 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2010/10/03/entity-framework-using-include-with-lambda-expressions/</guid>
      <description>I&amp;rsquo;m currently working on a project that uses Entity Framework 4. Even though lazy loading is enabled, I often use the ObjectQuery.Include method to eagerly load associated entities, in order to avoid database roundtrips when I access them:
var query =  from ord in db.Orders.Include(&amp;#34;OrderDetails&amp;#34;)  where ord.Date &amp;gt;= DateTime.Today  select ord; Or if I also want to eagerly load the product:
var query =  from ord in db.</description>
    </item>
    
    <item>
      <title>Automating null checks with Linq expressions</title>
      <link>https://thomaslevesque.com/2010/02/21/automating-null-checks-with-linq-expressions/</link>
      <pubDate>Sun, 21 Feb 2010 00:00:00 +0000</pubDate>
      
      <guid>https://thomaslevesque.com/2010/02/21/automating-null-checks-with-linq-expressions/</guid>
      <description>The problem Have you ever written code like the following ?
X xx = GetX(); string name = &amp;#34;Default&amp;#34;; if (xx != null &amp;amp;&amp;amp; xx.Foo != null &amp;amp;&amp;amp; xx.Foo.Bar != null &amp;amp;&amp;amp; xx.Foo.Bar.Baz != null) {  name = xx.Foo.Bar.Baz.Name; } I bet you have ! You just need to get the value of xx.Foo.Bar.Baz.Name, but you have to test every intermediate object to ensure that it&amp;rsquo;s not null. It can quickly become annoying if the property you need is nested in a deep object graph&amp;hellip;.</description>
    </item>
    
  </channel>
</rss>
