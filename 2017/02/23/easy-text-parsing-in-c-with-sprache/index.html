<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Easy text parsing in C# with Sprache - Thomas Levesque&#39;s .NET Blog</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="Easy text parsing in C# with Sprache" />
<meta property="og:description" content="A few days ago, I discovered a little gem: Sprache. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using parser combinators, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.
Text parsing Parsing text is a common task, but it can be tedious and error-prone." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://thomaslevesque.com/2017/02/23/easy-text-parsing-in-c-with-sprache/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-23T00:00:00+00:00" />
<meta property="article:modified_time" content="2017-02-23T00:00:00+00:00" />


	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Easy text parsing in C# with Sprache"/>
<meta name="twitter:description" content="A few days ago, I discovered a little gem: Sprache. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using parser combinators, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.
Text parsing Parsing text is a common task, but it can be tedious and error-prone."/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-31621259-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Thomas Levesque&#39;s .NET Blog" rel="home">
				<div class="logo__title">Thomas Levesque&#39;s .NET Blog</div>
				<div class="logo__tagline">Tips, tricks and thoughts about .NET development</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<a class="main__header__type" href="/posts/">posts</a>
			<h1 class="post__title">Easy text parsing in C# with Sprache</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class="meta__text" datetime="2017-02-23T00:00:00Z">February 23, 2017</time></div></div>
		</header><div class="content post__content clearfix">
			<p>A few days ago, I discovered a little gem: <a href="https://github.com/sprache/sprache">Sprache</a>. The name means &ldquo;language&rdquo; in German. It&rsquo;s a very elegant and easy to use library to create text parsers, using <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinators</a>, which are a very common technique in functional programming. The theorical concept may seem a bit scary, but as you&rsquo;ll see in a minute, Sprache makes it very simple.</p>
<h2 id="text-parsing">Text parsing</h2>
<p>Parsing text is a common task, but it can be tedious and error-prone. There are plenty of ways to do it:</p>
<ul>
<li>manual parsing based on <code>Split</code>, <code>IndexOf</code>, <code>Substring</code> etc.</li>
<li>regular expressions</li>
<li>hand-built parser that scans the string for tokens</li>
<li>full blown parser generated with ANTLR or a similar tool</li>
<li>and probably many others&hellip;</li>
</ul>
<p>None of these options is very appealing. For simple cases, splitting the string or using a regex can be enough, but it doesn&rsquo;t scale to more complex grammars. Building a real parser by hand for non-trivial grammars is, well, non-trivial. ANTLR requires Java, a bit of knowledge, and it relies on code generation, which complicates the build process.</p>
<p>Fortunately, <a href="https://github.com/sprache/sprache">Sprache</a> offers a very nice alternative. It provides many predefined parsers and combinators that you can use to define a grammar. Let&rsquo;s walk through an example: parsing the challenge in the <code>WWW-Authenticate</code> header of an HTTP response (I recently had to write a parser by hand for this recently, and I wish I had known Sprache then).</p>
<h2 id="the-grammar">The grammar</h2>
<p>The <code>WWW-Authenticate</code> header is sent by an HTTP server as part of a 401 (Unauthorized) response to indicate how you should authenticate:</p>
<pre tabindex="0"><code># Basic challenge
WWW-Authenticate: Basic realm=&quot;FooCorp&quot;

# OAuth 2.0 challenge after sending an expired token
WWW-Authenticate: Bearer realm=&quot;FooCorp&quot;, error=invalid_token, error_description=&quot;The access token has expired&quot;
</code></pre><p>What we want to parse is the &ldquo;challenge&rdquo;, i.e. the value of the header. So, we have an authentication scheme (<code>Basic</code>, <code>Bearer</code>), followed by one or more parameters (name-value pairs). This looks simple enough, we could probably just split by <code>','</code> then by <code>'='</code> to get the values&hellip; but the double quotes complicate things, since quoted strings could contain the <code>','</code> or <code>'='</code> characters. Also, the double quotes are optional if the parameter value is a single token, so we can&rsquo;t rely on the fact they will (or won&rsquo;t) be there. If we want to parse this reliably, we&rsquo;re going to have to look at the specs.</p>
<p>The <code>WWW-Authenticate</code> header is described in detail in <a href="https://tools.ietf.org/html/rfc2617">RFC-2617</a>. The grammar looks like this, in what the RFC calls &ldquo;augmented Backus-Naur Form&rdquo; (see <a href="https://tools.ietf.org/html/rfc2616#section-2.1">RFC 2616 §2.1</a>):</p>
<pre tabindex="0"><code># from RFC-2617 (HTTP Basic and Digest authentication)

challenge      = auth-scheme 1*SP 1#auth-param
auth-scheme    = token
auth-param     = token &quot;=&quot; ( token | quoted-string )

# from RFC2616 (HTTP/1.1)

token          = 1*&lt;any CHAR except CTLs or separators&gt;
separators     = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;
               | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;
               | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;
               | &quot;{&quot; | &quot;}&quot; | SP | HT
quoted-string  = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )
qdtext         = &lt;any TEXT except &lt;&quot;&gt;&gt;
quoted-pair    = &quot;\&quot; CHAR
</code></pre><p>So, we have a few grammar rules, let&rsquo;s see how we can encode them in C# code with Sprache, and use them to parse a challenge.</p>
<h2 id="parsing-tokens">Parsing tokens</h2>
<p>Let&rsquo;s start with the most simple parts of the grammar: tokens. A token is declared as one or more of any characters that are not control chars or separators.</p>
<p>We&rsquo;ll define our rules in a <code>Grammar</code> class. Let&rsquo;s start by defining some character classes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Grammar</span>
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; SeparatorChar =
        Parse.Chars(<span style="color:#e6db74">&#34;()&lt;&gt;@,;:\\\&#34;/[]?={} \t&#34;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; ControlChar =
        Parse.Char(Char.IsControl, <span style="color:#e6db74">&#34;Control character&#34;</span>);

}
</code></pre></div><ul>
<li>Each rule is declared as a <code>Parser&lt;T&gt;</code>; since these rules match single characters, they are of type <code>Parser&lt;char&gt;</code>.</li>
<li>The <code>Parse</code> class from Sprache exposes parser primitives and combinators.</li>
<li><code>Parse.Chars</code> matches any character from the specified string, we use it to specify the list of separator characters.</li>
<li>The overload of <code>Parse.Char</code> that we use here takes a predicate that will be called to check if the character matches, and a description of the character class. Here we just use <code>System.Char.IsControl</code> as the predicate to match control characters.</li>
</ul>
<p>Now, let&rsquo;s define a <code>TokenChar</code> character class to match characters that can be part of a token. As per the RFC, this can be any character not in the previous classes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; TokenChar =
        Parse.AnyChar
            .Except(SeparatorChar)
            .Except(ControlChar);
</code></pre></div><ul>
<li><code>Parse.AnyChar</code>, as the name implies, matches any character.</li>
<li><code>Except</code> specifies exceptions to the rule.</li>
</ul>
<p>Finally, a token is a sequence of one or more of these characters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; Token =
        TokenChar.AtLeastOnce().Text();
</code></pre></div><ul>
<li>A token is a string, so the rule for a token is of type <code>Parser&lt;string&gt;</code>.</li>
<li><code>AtLeastOnce()</code> means one or more repetitions, and since <code>TokenChar</code> is a <code>Parser&lt;char&gt;</code>, it returns a <code>Parser&lt;IEnumerable&lt;char&gt;&gt;</code>.</li>
<li><code>Text()</code> combines the sequence of characters into a string, returning a <code>Parser&lt;string&gt;</code>.</li>
</ul>
<p>We&rsquo;re now able to parse a token. But it&rsquo;s just a small step, and we still have a lot to do&hellip;</p>
<h2 id="parsing-quoted-strings">Parsing quoted strings</h2>
<p>The grammar defines a quoted string as a sequence of:</p>
<ul>
<li>an opening double quote</li>
<li>any number of either
<ul>
<li>a &ldquo;qdtext&rdquo;, which is any character except a double quote</li>
<li>a &ldquo;quoted pair&rdquo;, which is any character preceded by a backslash (this is used to escape double quotes inside a string)</li>
</ul>
</li>
<li>a closing double quote</li>
</ul>
<p>Let&rsquo;s write the rules for &ldquo;qdtext&rdquo; and &ldquo;quoted pair&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; DoubleQuote = Parse.Char(<span style="color:#e6db74">&#39;&#34;&#39;</span>);
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; Backslash = Parse.Char(<span style="color:#e6db74">&#39;\\&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; QdText =
        Parse.AnyChar.Except(DoubleQuote);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; QuotedPair =
        <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">_</span> <span style="color:#66d9ef">in</span> Backslash
        <span style="color:#66d9ef">from</span> c <span style="color:#66d9ef">in</span> Parse.AnyChar
        <span style="color:#66d9ef">select</span> c;
</code></pre></div><p>The <code>QdText</code> rule doesn&rsquo;t require much explanation, but <code>QuotedPair</code> is more interesting&hellip; As you can see, it looks like a Linq query: this is Sprache&rsquo;s way of specifying a sequence. This particular query means: <em>match a backslash (named <code>_</code> because we ignore it) followed by any character named <code>c</code>, and return just <code>c</code></em> (quoted pairs are not escape sequences in the same sense as in C, Java or C#, so <code>&quot;\n&quot;</code> isn&rsquo;t interpreted as &ldquo;new line&rdquo; but just as <code>&quot;n&quot;</code>).</p>
<p>We can now write the rule for a quoted string:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; QuotedString =
        <span style="color:#66d9ef">from</span> open <span style="color:#66d9ef">in</span> DoubleQuote
        <span style="color:#66d9ef">from</span> text <span style="color:#66d9ef">in</span> QuotedPair.Or(QdText).Many().Text()
        <span style="color:#66d9ef">from</span> close <span style="color:#66d9ef">in</span> DoubleQuote
        <span style="color:#66d9ef">select</span> text;
</code></pre></div><ul>
<li>the <code>Or</code> method indicates a choice between two parsers. <code>QuotedPair.Or(QdText)</code> will try to match a quoted pair, and if that fails, it will try to match a <code>QdText</code> instead.</li>
<li><code>Many()</code> indicates any number of repetition</li>
<li><code>Text()</code> combines the characters into a string</li>
</ul>
<p>We now have all the basic building blocks, so we can move on to higher level rules.</p>
<h3 id="parsing-challenge-parameters">Parsing challenge parameters</h3>
<p>A challenge is made of an auth scheme followed by one or more parameters. The auth scheme is trivial (it&rsquo;s just a token), so let&rsquo;s start by parsing the parameters.</p>
<p>Although there isn&rsquo;t a named rule for it in the grammar, let&rsquo;s define a rule for parameter values. The value can be either a token or a quoted string:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">string</span>&gt; ParameterValue =
        Token.Or(QuotedString);
</code></pre></div><p>Since a parameter is a composite element (name and value), let&rsquo;s define a class to represent it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Parameter</span>
{
    <span style="color:#66d9ef">public</span> Parameter(<span style="color:#66d9ef">string</span> name, <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span>)
    {
        Name = name;
        Value = <span style="color:#66d9ef">value</span>;
    }
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Name { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Value { <span style="color:#66d9ef">get</span>; }
}
</code></pre></div><p>The <code>T</code> in <code>Parser&lt;T&gt;</code> isn&rsquo;t restricted to characters and strings, it can be any type. So the rule for parsing parameters will be of type <code>Parser&lt;Parameter&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; EqualSign = Parse.Char(<span style="color:#e6db74">&#39;=&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter&gt; Parameter =
        <span style="color:#66d9ef">from</span> name <span style="color:#66d9ef">in</span> Token
        <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">_</span> <span style="color:#66d9ef">in</span> EqualSign
        <span style="color:#66d9ef">from</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> ParameterValue
        <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> Parameter(name, <span style="color:#66d9ef">value</span>);
</code></pre></div><p>Here we match a token (the parameter name), followed by the <code>'='</code> sign, followed by a parameter value, and we combine the name and value into a <code>Parameter</code> instance.</p>
<p>Now let&rsquo;s parse a sequence of one or more parameters. Parameters are separated by commas (<code>','</code>), with optional leading and trailing whitespace (look for &ldquo;#rule&rdquo; in <a href="https://tools.ietf.org/html/rfc2616#section-2.1">RFC 2616 §2.1</a>). The grammar for lists allows several commas without items in between, e.g. &ldquo;item1 ,, item2,item3, ,item4&rdquo;, so the rule for the delimiter can be written like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; Comma = Parse.Char(<span style="color:#e6db74">&#39;,&#39;</span>);

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;<span style="color:#66d9ef">char</span>&gt; ListDelimiter =
        <span style="color:#66d9ef">from</span> leading <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Many()
        <span style="color:#66d9ef">from</span> c <span style="color:#66d9ef">in</span> Comma
        <span style="color:#66d9ef">from</span> trailing <span style="color:#66d9ef">in</span> Parse.WhiteSpace.Or(Comma).Many()
        <span style="color:#66d9ef">select</span> c;
</code></pre></div><p>We just match the first comma, the rest can be any number of commas or whitespace characters. We return the comma because we have to return something, but we won&rsquo;t actually use it.</p>
<p>We could now match the sequence of parameters like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter[]&gt; Parameters =
        <span style="color:#66d9ef">from</span> first <span style="color:#66d9ef">in</span> Parameter.Once()
        <span style="color:#66d9ef">from</span> others <span style="color:#66d9ef">in</span> (
            <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">_</span> <span style="color:#66d9ef">in</span> ListDelimiter
            <span style="color:#66d9ef">from</span> p <span style="color:#66d9ef">in</span> Parameter
            <span style="color:#66d9ef">select</span> p).Many()
        <span style="color:#66d9ef">select</span> first.Concat(others).ToArray();
</code></pre></div><p>But it&rsquo;s not very straightforward&hellip; fortunately Sprache provides an easier option with the <code>DelimitedBy</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Parameter[]&gt; Parameters =
        <span style="color:#66d9ef">from</span> p <span style="color:#66d9ef">in</span> Parameter.DelimitedBy(ListDelimiter)
        <span style="color:#66d9ef">select</span> p.ToArray();
</code></pre></div><h2 id="parsing-the-challenge">Parsing the challenge</h2>
<p>We&rsquo;re almost done. We now have everything we need to parse the whole challenge. Let&rsquo;s define a class to represent it first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Challenge</span>
{
    <span style="color:#66d9ef">public</span> Challenge(<span style="color:#66d9ef">string</span> scheme, Parameter[] parameters)
    {
        Scheme = scheme;
        Parameters = parameters;
    }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Scheme { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> Parameter[] Parameters { <span style="color:#66d9ef">get</span>; }
}
</code></pre></div><p>And finally we can write the top-level rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Parser&lt;Challenge&gt; Challenge =
        <span style="color:#66d9ef">from</span> scheme <span style="color:#66d9ef">in</span> Token
        <span style="color:#66d9ef">from</span> <span style="color:#ae81ff">_</span> <span style="color:#66d9ef">in</span> Parse.WhiteSpace.AtLeastOnce()
        <span style="color:#66d9ef">from</span> parameters <span style="color:#66d9ef">in</span> Parameters
        <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">new</span> Challenge(scheme, parameters);
</code></pre></div><p>Note that I made this rule public, unlike the others: it&rsquo;s the only one we need to expose.</p>
<h2 id="using-the-parser">Using the parser</h2>
<p>Our parser is done, now we just have to use it, which is pretty straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">void</span> ParseAndPrintChallenge(<span style="color:#66d9ef">string</span> input)
{
    <span style="color:#66d9ef">var</span> challenge = Grammar.Challenge.Parse(input);
    Console.WriteLine(<span style="color:#e6db74">$&#34;Scheme: {challenge.Scheme}&#34;</span>);
    Console.WriteLine(<span style="color:#e6db74">$&#34;Parameters:&#34;</span>);
    <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> p <span style="color:#66d9ef">in</span> challenge.Parameters)
    {
        Console.WriteLine(<span style="color:#e6db74">$&#34;- {p.Name} = {p.Value}&#34;</span>);
    }
}
</code></pre></div><p>With the OAuth 2.0 challenge example from earlier, this produces the following output:</p>
<pre tabindex="0"><code>Scheme: Bearer
Parameters:
- realm = FooCorp
- error = invalid_token
- error_description = The access token has expired
</code></pre><p>If there&rsquo;s a syntax error in the input text, the <code>Parse</code> will throw a <code>ParseException</code> with a message describing where and why the parsing failed. For instance, if I remove the space between &ldquo;Bearer&rdquo; and &ldquo;realm&rdquo;, I get the following error:</p>
<blockquote>
<p>Parsing failure: unexpected &lsquo;='; expected whitespace (Line 1, Column 12); recently consumed: earerrealm</p>
</blockquote>
<p>You can find the full code for this article <a href="https://gist.github.com/thomaslevesque/d8ee28be1cf383a3f8aaf39cee776f92">here</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see, Sprache makes it very simple to parse complex text. The code isn&rsquo;t particularly short, but it&rsquo;s completely declarative; there are no loops, no conditionals, no temporary variables, no state&hellip; This makes it very easy to understand, and it can easily be compared with the actual grammar definition to check its correctness. It also provides pretty good feedback in case of error, which is hard to accomplish with a hand-built parser.</p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/parser/" rel="tag">parser</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/parser-combinator/" rel="tag">parser combinator</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/parsing/" rel="tag">parsing</a>
		</li>
		<li class="tags__item">
			<a class="tags__link btn" href="/tags/sprache/" rel="tag">sprache</a>
		</li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Thomas Levesque avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Thomas Levesque</span>
	</div>
	<div class="authorbox__description">
		Thomas Levesque is a French software developer from Paris.
	</div>
</div>

<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/2017/02/20/whats-new-in-fakeiteasy-3-0-0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">What&#39;s new in FakeItEasy 3.0.0?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/2017/03/29/linq-performance-improvements-in-net-core/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linq performance improvements in .NET Core</p>
		</a>
	</div>
</nav>

<div>
    <script src="https://utteranc.es/client.js"
            repo="thomaslevesque/blog"
            issue-term="pathname"
            label="post-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
</div>


			</div>
			<aside class="sidebar"><div class="widget-search widget">
	<form class="widget-search__form" role="search" method="get" action="https://google.com/search">
		<label>
			<input class="widget-search__field" type="search" placeholder="SEARCH..." value="" name="q" aria-label="SEARCH...">
		</label>
		<input class="widget-search__submit" type="submit" value="Search">
		<input type="hidden" name="sitesearch" value="https://thomaslevesque.com/" />
	</form>
</div>
<div class="widget-social widget">
    <h4 class="widget-social__title widget__title">Social</h4>
    <div class="widget-social__content widget__content">
        <a class="widget-social__link-custom widget__link" title="GitHub" rel="noopener noreferrer" href="https://github.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
        </a>
        <a class="widget-social__link-custom widget__link" title="Twitter" rel="noopener noreferrer" href="https://twitter.com/thomaslevesque" target="_blank">
            <svg class="widget-social__link-icon-custom icon icon-twitter" width="24" height="24" viewBox="0 0 384 312"><path d="m384 36.9c-14.1 6.3-29.3 10.5-45.2 12.4 16.3-9.7 28.8-25.2 34.6-43.6-15.2 9-32.1 15.6-50 19.1-14.4-15.2-34.9-24.8-57.5-24.8-43.5 0-78.8 35.3-78.8 78.8 0 6.2.7 12.2 2 17.9-65.5-3.3-123.5-34.6-162.4-82.3-6.7 11.6-10.6 25.2-10.6 39.6 0 27.3 13.9 51.4 35 65.6-12.9-.4-25.1-4-35.7-9.9v1c0 38.2 27.2 70 63.2 77.2-6.6 1.8-13.6 2.8-20.8 2.8-5.1 0-10-.5-14.8-1.4 10 31.3 39.1 54.1 73.6 54.7-27 21.1-60.9 33.7-97.8 33.7-6.4 0-12.6-.4-18.8-1.1 34.9 22.4 76.3 35.4 120.8 35.4 144.9 0 224.1-120 224.1-224.1 0-3.4-.1-6.8-.2-10.2 15.4-11.1 28.7-25 39.3-40.8z"/></svg>
        </a>
        <a class="widget-social__link-custom widget__link" title="RSS feed" rel="noopener noreferrer" href="/index.xml">
            <svg class="widget-social__link-icon-custom icon icon-rss" x="0px" y="0px" width="24" height="24" viewBox="0 0 1000 1000"><path d="M277.2,856.3c0,37.1-13,68.7-39,94.6c-26,26-57.5,39-94.6,39S75,976.9,49,951c-26-26-39-57.5-39-94.6c0-37.1,13-68.7,39-94.6c26-26,57.5-39,94.6-39s68.7,13,94.6,39C264.3,787.7,277.2,819.2,277.2,856.3z M633.6,941.9c0.9,13-3,24.1-11.8,33.4c-8.4,9.7-19.3,14.6-32.7,14.6h-94c-11.6,0-21.6-3.8-29.9-11.5c-8.4-7.7-13-17.3-13.9-28.9c-10.2-106.2-53-197.1-128.4-272.5c-75.4-75.4-166.2-118.2-272.5-128.4c-11.6-0.9-21.2-5.6-28.9-13.9c-7.7-8.4-11.5-18.3-11.5-29.9v-94c0-13.5,4.9-24.4,14.6-32.7c7.9-7.9,17.9-11.8,29.9-11.8H58c74.2,6,145.2,24.7,213,56c67.7,31.3,127.8,73.4,180.2,126.3c52.9,52.4,95,112.5,126.3,180.2C608.8,796.7,627.5,867.7,633.6,941.9L633.6,941.9z M989.9,943.3c0.9,12.5-3.2,23.4-12.5,32.7c-8.3,9.3-19,13.9-32,13.9h-99.5c-12.1,0-22.4-4.1-31-12.2s-13.1-18-13.6-29.6c-5.6-99.8-29-194.5-70.3-284.3c-41.3-89.8-95-167.7-161.1-233.8C503.8,363.9,425.8,310.2,336,269c-89.8-41.3-184.5-65-284.3-71c-11.6-0.5-21.5-5-29.6-13.6c-8.1-8.6-12.2-18.7-12.2-30.3V54.6c0-13,4.6-23.7,13.9-32c8.4-8.4,18.6-12.5,30.6-12.5h2.1c121.6,6,237.9,33.9,349,83.5c111.1,49.6,209.8,117.8,296.1,204.6c86.8,86.3,155,185,204.6,296.1C956,705.4,983.8,821.8,989.9,943.3L989.9,943.3z"/></svg>
        </a>
    </div>
</div>
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/2021/11/12/building-a-project-that-target-net-45-in-visual-studio-2022/">Building a project that target .NET Framework 4.5 in Visual Studio 2022</a></li>
			<li class="widget__item"><a class="widget__link" href="/2021/11/04/a-quick-review-of-csharp-10-new-language-features/">A quick review of C# 10 new language features</a></li>
			<li class="widget__item"><a class="widget__link" href="/2021/03/19/csharp-9-records-as-strongly-typed-ids-part-5-final-bits-and-conclusion/">C# 9 records as strongly-typed ids - Part 5: final bits and conclusion</a></li>
			<li class="widget__item"><a class="widget__link" href="/2020/12/23/csharp-9-records-as-strongly-typed-ids-part-4-entity-framework-core-integration/">C# 9 records as strongly-typed ids - Part 4: Entity Framework Core integration</a></li>
			<li class="widget__item"><a class="widget__link" href="/2020/12/07/csharp-9-records-as-strongly-typed-ids-part-3-json-serialization/">C# 9 records as strongly-typed ids - Part 3: JSON serialization</a></li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Top tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23/" title="c#">c#</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/wpf/" title="wpf">wpf</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/asp.net-core/" title="asp.net-core">asp.net-core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/xaml/" title="xaml">xaml</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/async/" title="async">async</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/visual-studio/" title="visual-studio">visual-studio</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/.net-core/" title=".net-core">.net-core</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/json/" title="json">json</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/c%23-9/" title="c#-9">c#-9</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linq/" title="linq">linq</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/unit-testing/" title="unit-testing">unit-testing</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/binding/" title="binding">binding</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/dependency-injection/" title="dependency-injection">dependency-injection</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/markup-extension/" title="markup-extension">markup-extension</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/mvvm/" title="mvvm">mvvm</a>
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2022 Thomas Levesque.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>